// @generated
// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_LOGSCONFIGSTRUCTURES_FACEBOOK_LOGDEVICE_LOGSCONFIG_FBUFFERS_H_
#define FLATBUFFERS_GENERATED_LOGSCONFIGSTRUCTURES_FACEBOOK_LOGDEVICE_LOGSCONFIG_FBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace facebook {
namespace logdevice {
namespace logsconfig {
namespace fbuffers {

struct Bool;

struct Int;

struct UInt8;

struct NoValueSet;

struct Long;

struct ULong;

struct String;

struct Permission;

struct ExtraAttr;

struct ScopeReplication;

struct Shadow;

struct Header;

struct LogRange;

struct LogAttr;

struct LogAttrs;

struct LogGroup;

struct Directory;

struct LogsConfig;

struct LogGroupInDirectory;

struct Delta;

struct MkDir_Msg;

struct SetTree_Msg;

struct Rm_Msg;

struct Rename_Msg;

struct SetAttrs_Msg;

struct SetLogRange_Msg;

struct MkLog_Msg;

struct RESET_Msg;

struct BatchDelta;

enum class ConflictResolutionMode : int8_t {
  Strict = 0,
  Auto = 1,
  MIN = Strict,
  MAX = Auto
};

inline const char **EnumNamesConflictResolutionMode() {
  static const char *names[] = { "Strict", "Auto", nullptr };
  return names;
}

inline const char *EnumNameConflictResolutionMode(ConflictResolutionMode e) { return EnumNamesConflictResolutionMode()[static_cast<int>(e)]; }

enum class Any : uint8_t {
  NONE = 0,
  NoValueSet = 1,
  UInt8 = 2,
  Int = 3,
  Bool = 4,
  ULong = 5,
  Long = 6,
  String = 7,
  MIN = NONE,
  MAX = String
};

inline const char **EnumNamesAny() {
  static const char *names[] = { "NONE", "NoValueSet", "UInt8", "Int", "Bool", "ULong", "Long", "String", nullptr };
  return names;
}

inline const char *EnumNameAny(Any e) { return EnumNamesAny()[static_cast<int>(e)]; }

template<typename T> struct AnyTraits {
  static const Any enum_value = Any::NONE;
};

template<> struct AnyTraits<NoValueSet> {
  static const Any enum_value = Any::NoValueSet;
};

template<> struct AnyTraits<UInt8> {
  static const Any enum_value = Any::UInt8;
};

template<> struct AnyTraits<Int> {
  static const Any enum_value = Any::Int;
};

template<> struct AnyTraits<Bool> {
  static const Any enum_value = Any::Bool;
};

template<> struct AnyTraits<ULong> {
  static const Any enum_value = Any::ULong;
};

template<> struct AnyTraits<Long> {
  static const Any enum_value = Any::Long;
};

template<> struct AnyTraits<String> {
  static const Any enum_value = Any::String;
};

inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, Any type);

enum class DeltaPayload : uint8_t {
  NONE = 0,
  MkDir_Msg = 1,
  Rm_Msg = 2,
  Rename_Msg = 3,
  SetAttrs_Msg = 4,
  SetLogRange_Msg = 5,
  MkLog_Msg = 6,
  BatchDelta = 7,
  SetTree_Msg = 8,
  MIN = NONE,
  MAX = SetTree_Msg
};

inline const char **EnumNamesDeltaPayload() {
  static const char *names[] = { "NONE", "MkDir_Msg", "Rm_Msg", "Rename_Msg", "SetAttrs_Msg", "SetLogRange_Msg", "MkLog_Msg", "BatchDelta", "SetTree_Msg", nullptr };
  return names;
}

inline const char *EnumNameDeltaPayload(DeltaPayload e) { return EnumNamesDeltaPayload()[static_cast<int>(e)]; }

template<typename T> struct DeltaPayloadTraits {
  static const DeltaPayload enum_value = DeltaPayload::NONE;
};

template<> struct DeltaPayloadTraits<MkDir_Msg> {
  static const DeltaPayload enum_value = DeltaPayload::MkDir_Msg;
};

template<> struct DeltaPayloadTraits<Rm_Msg> {
  static const DeltaPayload enum_value = DeltaPayload::Rm_Msg;
};

template<> struct DeltaPayloadTraits<Rename_Msg> {
  static const DeltaPayload enum_value = DeltaPayload::Rename_Msg;
};

template<> struct DeltaPayloadTraits<SetAttrs_Msg> {
  static const DeltaPayload enum_value = DeltaPayload::SetAttrs_Msg;
};

template<> struct DeltaPayloadTraits<SetLogRange_Msg> {
  static const DeltaPayload enum_value = DeltaPayload::SetLogRange_Msg;
};

template<> struct DeltaPayloadTraits<MkLog_Msg> {
  static const DeltaPayload enum_value = DeltaPayload::MkLog_Msg;
};

template<> struct DeltaPayloadTraits<BatchDelta> {
  static const DeltaPayload enum_value = DeltaPayload::BatchDelta;
};

template<> struct DeltaPayloadTraits<SetTree_Msg> {
  static const DeltaPayload enum_value = DeltaPayload::SetTree_Msg;
};

inline bool VerifyDeltaPayload(flatbuffers::Verifier &verifier, const void *union_obj, DeltaPayload type);

MANUALLY_ALIGNED_STRUCT(8) Header FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t base_lsn_;
  int8_t resolution_mode_;
  int8_t __padding0;
  int16_t __padding1;
  int32_t __padding2;

 public:
  Header() { memset(this, 0, sizeof(Header)); }
  Header(const Header &_o) { memcpy(this, &_o, sizeof(Header)); }
  Header(uint64_t _base_lsn, ConflictResolutionMode _resolution_mode)
    : base_lsn_(flatbuffers::EndianScalar(_base_lsn)), resolution_mode_(flatbuffers::EndianScalar(static_cast<int8_t>(_resolution_mode))), __padding0(0), __padding1(0), __padding2(0) { (void)__padding0; (void)__padding1; (void)__padding2; }

  uint64_t base_lsn() const { return flatbuffers::EndianScalar(base_lsn_); }
  ConflictResolutionMode resolution_mode() const { return static_cast<ConflictResolutionMode>(flatbuffers::EndianScalar(resolution_mode_)); }
};
STRUCT_END(Header, 16);

struct Bool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  bool value() const { return GetField<uint8_t>(VT_VALUE, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct BoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) { fbb_.AddElement<uint8_t>(Bool::VT_VALUE, static_cast<uint8_t>(value), 0); }
  BoolBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BoolBuilder &operator=(const BoolBuilder &);
  flatbuffers::Offset<Bool> Finish() {
    auto o = flatbuffers::Offset<Bool>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Bool> CreateBool(flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BoolBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int32_t value() const { return GetField<int32_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct IntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) { fbb_.AddElement<int32_t>(Int::VT_VALUE, value, 0); }
  IntBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  IntBuilder &operator=(const IntBuilder &);
  flatbuffers::Offset<Int> Finish() {
    auto o = flatbuffers::Offset<Int>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Int> CreateInt(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UInt8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  uint8_t value() const { return GetField<uint8_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UInt8Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) { fbb_.AddElement<uint8_t>(UInt8::VT_VALUE, value, 0); }
  UInt8Builder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UInt8Builder &operator=(const UInt8Builder &);
  flatbuffers::Offset<UInt8> Finish() {
    auto o = flatbuffers::Offset<UInt8>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<UInt8> CreateUInt8(flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  UInt8Builder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NoValueSet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NoValueSetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  NoValueSetBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NoValueSetBuilder &operator=(const NoValueSetBuilder &);
  flatbuffers::Offset<NoValueSet> Finish() {
    auto o = flatbuffers::Offset<NoValueSet>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<NoValueSet> CreateNoValueSet(flatbuffers::FlatBufferBuilder &_fbb) {
  NoValueSetBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Long FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int64_t value() const { return GetField<int64_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct LongBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) { fbb_.AddElement<int64_t>(Long::VT_VALUE, value, 0); }
  LongBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LongBuilder &operator=(const LongBuilder &);
  flatbuffers::Offset<Long> Finish() {
    auto o = flatbuffers::Offset<Long>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Long> CreateLong(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  LongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct ULong FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  uint64_t value() const { return GetField<uint64_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ULongBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) { fbb_.AddElement<uint64_t>(ULong::VT_VALUE, value, 0); }
  ULongBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ULongBuilder &operator=(const ULongBuilder &);
  flatbuffers::Offset<ULong> Finish() {
    auto o = flatbuffers::Offset<ULong>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<ULong> CreateULong(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  ULongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const { return GetPointer<const flatbuffers::String *>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) { fbb_.AddOffset(String::VT_VALUE, value); }
  StringBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  StringBuilder &operator=(const StringBuilder &);
  flatbuffers::Offset<String> Finish() {
    auto o = flatbuffers::Offset<String>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  return CreateString(_fbb, value ? _fbb.CreateString(value) : 0);
}

struct Permission FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRINCIPAL = 4,
    VT_ACTIONS = 6
  };
  const flatbuffers::String *principal() const { return GetPointer<const flatbuffers::String *>(VT_PRINCIPAL); }
  bool KeyCompareLessThan(const Permission *o) const { return *principal() < *o->principal(); }
  int KeyCompareWithValue(const char *val) const { return strcmp(principal()->c_str(), val); }
  const flatbuffers::Vector<uint8_t> *actions() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ACTIONS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PRINCIPAL) &&
           verifier.Verify(principal()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ACTIONS) &&
           verifier.Verify(actions()) &&
           verifier.EndTable();
  }
};

struct PermissionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_principal(flatbuffers::Offset<flatbuffers::String> principal) { fbb_.AddOffset(Permission::VT_PRINCIPAL, principal); }
  void add_actions(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> actions) { fbb_.AddOffset(Permission::VT_ACTIONS, actions); }
  PermissionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PermissionBuilder &operator=(const PermissionBuilder &);
  flatbuffers::Offset<Permission> Finish() {
    auto o = flatbuffers::Offset<Permission>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, Permission::VT_PRINCIPAL);  // principal
    return o;
  }
};

inline flatbuffers::Offset<Permission> CreatePermission(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> principal = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> actions = 0) {
  PermissionBuilder builder_(_fbb);
  builder_.add_actions(actions);
  builder_.add_principal(principal);
  return builder_.Finish();
}

inline flatbuffers::Offset<Permission> CreatePermissionDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *principal = nullptr,
    const std::vector<uint8_t> *actions = nullptr) {
  return CreatePermission(_fbb, principal ? _fbb.CreateString(principal) : 0, actions ? _fbb.CreateVector<uint8_t>(*actions) : 0);
}

struct ExtraAttr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const { return GetPointer<const flatbuffers::String *>(VT_KEY); }
  bool KeyCompareLessThan(const ExtraAttr *o) const { return *key() < *o->key(); }
  int KeyCompareWithValue(const char *val) const { return strcmp(key()->c_str(), val); }
  const flatbuffers::String *value() const { return GetPointer<const flatbuffers::String *>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_KEY) &&
           verifier.Verify(key()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct ExtraAttrBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) { fbb_.AddOffset(ExtraAttr::VT_KEY, key); }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) { fbb_.AddOffset(ExtraAttr::VT_VALUE, value); }
  ExtraAttrBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ExtraAttrBuilder &operator=(const ExtraAttrBuilder &);
  flatbuffers::Offset<ExtraAttr> Finish() {
    auto o = flatbuffers::Offset<ExtraAttr>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, ExtraAttr::VT_KEY);  // key
    return o;
  }
};

inline flatbuffers::Offset<ExtraAttr> CreateExtraAttr(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  ExtraAttrBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExtraAttr> CreateExtraAttrDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  return CreateExtraAttr(_fbb, key ? _fbb.CreateString(key) : 0, value ? _fbb.CreateString(value) : 0);
}

struct ScopeReplication FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCOPE = 4,
    VT_REPLICATION_FACTOR = 6
  };
  uint8_t scope() const { return GetField<uint8_t>(VT_SCOPE, 0); }
  bool KeyCompareLessThan(const ScopeReplication *o) const { return scope() < o->scope(); }
  int KeyCompareWithValue(uint8_t val) const { return scope() < val ? -1 : scope() > val; }
  uint8_t replication_factor() const { return GetField<uint8_t>(VT_REPLICATION_FACTOR, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SCOPE) &&
           VerifyField<uint8_t>(verifier, VT_REPLICATION_FACTOR) &&
           verifier.EndTable();
  }
};

struct ScopeReplicationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scope(uint8_t scope) { fbb_.AddElement<uint8_t>(ScopeReplication::VT_SCOPE, scope, 0); }
  void add_replication_factor(uint8_t replication_factor) { fbb_.AddElement<uint8_t>(ScopeReplication::VT_REPLICATION_FACTOR, replication_factor, 0); }
  ScopeReplicationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ScopeReplicationBuilder &operator=(const ScopeReplicationBuilder &);
  flatbuffers::Offset<ScopeReplication> Finish() {
    auto o = flatbuffers::Offset<ScopeReplication>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ScopeReplication> CreateScopeReplication(flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t scope = 0,
    uint8_t replication_factor = 0) {
  ScopeReplicationBuilder builder_(_fbb);
  builder_.add_replication_factor(replication_factor);
  builder_.add_scope(scope);
  return builder_.Finish();
}

struct Shadow FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DESTINATION = 4,
    VT_RATIO = 6
  };
  const flatbuffers::String *destination() const { return GetPointer<const flatbuffers::String *>(VT_DESTINATION); }
  float ratio() const { return GetField<float>(VT_RATIO, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DESTINATION) &&
           verifier.Verify(destination()) &&
           VerifyField<float>(verifier, VT_RATIO) &&
           verifier.EndTable();
  }
};

struct ShadowBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_destination(flatbuffers::Offset<flatbuffers::String> destination) { fbb_.AddOffset(Shadow::VT_DESTINATION, destination); }
  void add_ratio(float ratio) { fbb_.AddElement<float>(Shadow::VT_RATIO, ratio, 0.0f); }
  ShadowBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ShadowBuilder &operator=(const ShadowBuilder &);
  flatbuffers::Offset<Shadow> Finish() {
    auto o = flatbuffers::Offset<Shadow>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Shadow> CreateShadow(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> destination = 0,
    float ratio = 0.0f) {
  ShadowBuilder builder_(_fbb);
  builder_.add_ratio(ratio);
  builder_.add_destination(destination);
  return builder_.Finish();
}

inline flatbuffers::Offset<Shadow> CreateShadowDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *destination = nullptr,
    float ratio = 0.0f) {
  return CreateShadow(_fbb, destination ? _fbb.CreateString(destination) : 0, ratio);
}

struct LogRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FROM = 4,
    VT_TO = 6
  };
  uint64_t from() const { return GetField<uint64_t>(VT_FROM, 0); }
  uint64_t to() const { return GetField<uint64_t>(VT_TO, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FROM) &&
           VerifyField<uint64_t>(verifier, VT_TO) &&
           verifier.EndTable();
  }
};

struct LogRangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_from(uint64_t from) { fbb_.AddElement<uint64_t>(LogRange::VT_FROM, from, 0); }
  void add_to(uint64_t to) { fbb_.AddElement<uint64_t>(LogRange::VT_TO, to, 0); }
  LogRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LogRangeBuilder &operator=(const LogRangeBuilder &);
  flatbuffers::Offset<LogRange> Finish() {
    auto o = flatbuffers::Offset<LogRange>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<LogRange> CreateLogRange(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t from = 0,
    uint64_t to = 0) {
  LogRangeBuilder builder_(_fbb);
  builder_.add_to(to);
  builder_.add_from(from);
  return builder_.Finish();
}

struct LogAttr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_INHERITED = 6,
    VT_VALUE_TYPE = 8,
    VT_VALUE = 10
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  bool KeyCompareLessThan(const LogAttr *o) const { return *name() < *o->name(); }
  int KeyCompareWithValue(const char *val) const { return strcmp(name()->c_str(), val); }
  bool inherited() const { return GetField<uint8_t>(VT_INHERITED, 0) != 0; }
  Any value_type() const { return static_cast<Any>(GetField<uint8_t>(VT_VALUE_TYPE, 0)); }
  const void *value() const { return GetPointer<const void *>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_INHERITED) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           VerifyAny(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

struct LogAttrBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(LogAttr::VT_NAME, name); }
  void add_inherited(bool inherited) { fbb_.AddElement<uint8_t>(LogAttr::VT_INHERITED, static_cast<uint8_t>(inherited), 0); }
  void add_value_type(Any value_type) { fbb_.AddElement<uint8_t>(LogAttr::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0); }
  void add_value(flatbuffers::Offset<void> value) { fbb_.AddOffset(LogAttr::VT_VALUE, value); }
  LogAttrBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LogAttrBuilder &operator=(const LogAttrBuilder &);
  flatbuffers::Offset<LogAttr> Finish() {
    auto o = flatbuffers::Offset<LogAttr>(fbb_.EndTable(start_, 4));
    fbb_.Required(o, LogAttr::VT_NAME);  // name
    return o;
  }
};

inline flatbuffers::Offset<LogAttr> CreateLogAttr(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool inherited = false,
    Any value_type = Any::NONE,
    flatbuffers::Offset<void> value = 0) {
  LogAttrBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  builder_.add_inherited(inherited);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogAttr> CreateLogAttrDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool inherited = false,
    Any value_type = Any::NONE,
    flatbuffers::Offset<void> value = 0) {
  return CreateLogAttr(_fbb, name ? _fbb.CreateString(name) : 0, inherited, value_type, value);
}

struct LogAttrs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTRIBUTES = 4,
    VT_PERMISSIONS = 6,
    VT_EXTRAS = 8,
    VT_REPLICATE_ACROSS = 10,
    VT_ACLS = 12,
    VT_ACLS_SHADOW = 14,
    VT_SHADOW = 16
  };
  const flatbuffers::Vector<flatbuffers::Offset<LogAttr>> *attributes() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LogAttr>> *>(VT_ATTRIBUTES); }
  const flatbuffers::Vector<flatbuffers::Offset<Permission>> *permissions() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Permission>> *>(VT_PERMISSIONS); }
  const flatbuffers::Vector<flatbuffers::Offset<ExtraAttr>> *extras() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ExtraAttr>> *>(VT_EXTRAS); }
  const flatbuffers::Vector<flatbuffers::Offset<ScopeReplication>> *replicate_across() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ScopeReplication>> *>(VT_REPLICATE_ACROSS); }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *acls() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ACLS); }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *acls_shadow() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ACLS_SHADOW); }
  const Shadow *shadow() const { return GetPointer<const Shadow *>(VT_SHADOW); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTRIBUTES) &&
           verifier.Verify(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PERMISSIONS) &&
           verifier.Verify(permissions()) &&
           verifier.VerifyVectorOfTables(permissions()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EXTRAS) &&
           verifier.Verify(extras()) &&
           verifier.VerifyVectorOfTables(extras()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_REPLICATE_ACROSS) &&
           verifier.Verify(replicate_across()) &&
           verifier.VerifyVectorOfTables(replicate_across()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ACLS) &&
           verifier.Verify(acls()) &&
           verifier.VerifyVectorOfStrings(acls()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ACLS_SHADOW) &&
           verifier.Verify(acls_shadow()) &&
           verifier.VerifyVectorOfStrings(acls_shadow()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SHADOW) &&
           verifier.VerifyTable(shadow()) &&
           verifier.EndTable();
  }
};

struct LogAttrsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LogAttr>>> attributes) { fbb_.AddOffset(LogAttrs::VT_ATTRIBUTES, attributes); }
  void add_permissions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Permission>>> permissions) { fbb_.AddOffset(LogAttrs::VT_PERMISSIONS, permissions); }
  void add_extras(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExtraAttr>>> extras) { fbb_.AddOffset(LogAttrs::VT_EXTRAS, extras); }
  void add_replicate_across(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ScopeReplication>>> replicate_across) { fbb_.AddOffset(LogAttrs::VT_REPLICATE_ACROSS, replicate_across); }
  void add_acls(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> acls) { fbb_.AddOffset(LogAttrs::VT_ACLS, acls); }
  void add_acls_shadow(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> acls_shadow) { fbb_.AddOffset(LogAttrs::VT_ACLS_SHADOW, acls_shadow); }
  void add_shadow(flatbuffers::Offset<Shadow> shadow) { fbb_.AddOffset(LogAttrs::VT_SHADOW, shadow); }
  LogAttrsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LogAttrsBuilder &operator=(const LogAttrsBuilder &);
  flatbuffers::Offset<LogAttrs> Finish() {
    auto o = flatbuffers::Offset<LogAttrs>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<LogAttrs> CreateLogAttrs(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LogAttr>>> attributes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Permission>>> permissions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExtraAttr>>> extras = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ScopeReplication>>> replicate_across = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> acls = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> acls_shadow = 0,
    flatbuffers::Offset<Shadow> shadow = 0) {
  LogAttrsBuilder builder_(_fbb);
  builder_.add_shadow(shadow);
  builder_.add_acls_shadow(acls_shadow);
  builder_.add_acls(acls);
  builder_.add_replicate_across(replicate_across);
  builder_.add_extras(extras);
  builder_.add_permissions(permissions);
  builder_.add_attributes(attributes);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogAttrs> CreateLogAttrsDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<LogAttr>> *attributes = nullptr,
    const std::vector<flatbuffers::Offset<Permission>> *permissions = nullptr,
    const std::vector<flatbuffers::Offset<ExtraAttr>> *extras = nullptr,
    const std::vector<flatbuffers::Offset<ScopeReplication>> *replicate_across = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *acls = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *acls_shadow = nullptr,
    flatbuffers::Offset<Shadow> shadow = 0) {
  return CreateLogAttrs(_fbb, attributes ? _fbb.CreateVector<flatbuffers::Offset<LogAttr>>(*attributes) : 0, permissions ? _fbb.CreateVector<flatbuffers::Offset<Permission>>(*permissions) : 0, extras ? _fbb.CreateVector<flatbuffers::Offset<ExtraAttr>>(*extras) : 0, replicate_across ? _fbb.CreateVector<flatbuffers::Offset<ScopeReplication>>(*replicate_across) : 0, acls ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*acls) : 0, acls_shadow ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*acls_shadow) : 0, shadow);
}

struct LogGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_RANGE = 6,
    VT_ATTRS = 8
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const LogRange *range() const { return GetPointer<const LogRange *>(VT_RANGE); }
  const LogAttrs *attrs() const { return GetPointer<const LogAttrs *>(VT_ATTRS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RANGE) &&
           verifier.VerifyTable(range()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTRS) &&
           verifier.VerifyTable(attrs()) &&
           verifier.EndTable();
  }
};

struct LogGroupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(LogGroup::VT_NAME, name); }
  void add_range(flatbuffers::Offset<LogRange> range) { fbb_.AddOffset(LogGroup::VT_RANGE, range); }
  void add_attrs(flatbuffers::Offset<LogAttrs> attrs) { fbb_.AddOffset(LogGroup::VT_ATTRS, attrs); }
  LogGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LogGroupBuilder &operator=(const LogGroupBuilder &);
  flatbuffers::Offset<LogGroup> Finish() {
    auto o = flatbuffers::Offset<LogGroup>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<LogGroup> CreateLogGroup(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<LogRange> range = 0,
    flatbuffers::Offset<LogAttrs> attrs = 0) {
  LogGroupBuilder builder_(_fbb);
  builder_.add_attrs(attrs);
  builder_.add_range(range);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogGroup> CreateLogGroupDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<LogRange> range = 0,
    flatbuffers::Offset<LogAttrs> attrs = 0) {
  return CreateLogGroup(_fbb, name ? _fbb.CreateString(name) : 0, range, attrs);
}

struct Directory FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_ATTRS = 6,
    VT_LOG_GROUPS = 8,
    VT_CHILDREN = 10
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const LogAttrs *attrs() const { return GetPointer<const LogAttrs *>(VT_ATTRS); }
  const flatbuffers::Vector<flatbuffers::Offset<LogGroup>> *log_groups() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LogGroup>> *>(VT_LOG_GROUPS); }
  const flatbuffers::Vector<flatbuffers::Offset<Directory>> *children() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Directory>> *>(VT_CHILDREN); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTRS) &&
           verifier.VerifyTable(attrs()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LOG_GROUPS) &&
           verifier.Verify(log_groups()) &&
           verifier.VerifyVectorOfTables(log_groups()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
};

struct DirectoryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Directory::VT_NAME, name); }
  void add_attrs(flatbuffers::Offset<LogAttrs> attrs) { fbb_.AddOffset(Directory::VT_ATTRS, attrs); }
  void add_log_groups(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LogGroup>>> log_groups) { fbb_.AddOffset(Directory::VT_LOG_GROUPS, log_groups); }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Directory>>> children) { fbb_.AddOffset(Directory::VT_CHILDREN, children); }
  DirectoryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DirectoryBuilder &operator=(const DirectoryBuilder &);
  flatbuffers::Offset<Directory> Finish() {
    auto o = flatbuffers::Offset<Directory>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<Directory> CreateDirectory(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<LogAttrs> attrs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LogGroup>>> log_groups = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Directory>>> children = 0) {
  DirectoryBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_log_groups(log_groups);
  builder_.add_attrs(attrs);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Directory> CreateDirectoryDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<LogAttrs> attrs = 0,
    const std::vector<flatbuffers::Offset<LogGroup>> *log_groups = nullptr,
    const std::vector<flatbuffers::Offset<Directory>> *children = nullptr) {
  return CreateDirectory(_fbb, name ? _fbb.CreateString(name) : 0, attrs, log_groups ? _fbb.CreateVector<flatbuffers::Offset<LogGroup>>(*log_groups) : 0, children ? _fbb.CreateVector<flatbuffers::Offset<Directory>>(*children) : 0);
}

struct LogsConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_ROOT_DIR = 6
  };
  uint64_t version() const { return GetField<uint64_t>(VT_VERSION, 0); }
  const Directory *root_dir() const { return GetPointer<const Directory *>(VT_ROOT_DIR); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VERSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ROOT_DIR) &&
           verifier.VerifyTable(root_dir()) &&
           verifier.EndTable();
  }
};

struct LogsConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint64_t version) { fbb_.AddElement<uint64_t>(LogsConfig::VT_VERSION, version, 0); }
  void add_root_dir(flatbuffers::Offset<Directory> root_dir) { fbb_.AddOffset(LogsConfig::VT_ROOT_DIR, root_dir); }
  LogsConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LogsConfigBuilder &operator=(const LogsConfigBuilder &);
  flatbuffers::Offset<LogsConfig> Finish() {
    auto o = flatbuffers::Offset<LogsConfig>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<LogsConfig> CreateLogsConfig(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t version = 0,
    flatbuffers::Offset<Directory> root_dir = 0) {
  LogsConfigBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_root_dir(root_dir);
  return builder_.Finish();
}

struct LogGroupInDirectory FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOG_GROUP = 4,
    VT_PARENT_PATH = 6
  };
  const LogGroup *log_group() const { return GetPointer<const LogGroup *>(VT_LOG_GROUP); }
  const flatbuffers::String *parent_path() const { return GetPointer<const flatbuffers::String *>(VT_PARENT_PATH); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LOG_GROUP) &&
           verifier.VerifyTable(log_group()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PARENT_PATH) &&
           verifier.Verify(parent_path()) &&
           verifier.EndTable();
  }
};

struct LogGroupInDirectoryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_log_group(flatbuffers::Offset<LogGroup> log_group) { fbb_.AddOffset(LogGroupInDirectory::VT_LOG_GROUP, log_group); }
  void add_parent_path(flatbuffers::Offset<flatbuffers::String> parent_path) { fbb_.AddOffset(LogGroupInDirectory::VT_PARENT_PATH, parent_path); }
  LogGroupInDirectoryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LogGroupInDirectoryBuilder &operator=(const LogGroupInDirectoryBuilder &);
  flatbuffers::Offset<LogGroupInDirectory> Finish() {
    auto o = flatbuffers::Offset<LogGroupInDirectory>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<LogGroupInDirectory> CreateLogGroupInDirectory(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LogGroup> log_group = 0,
    flatbuffers::Offset<flatbuffers::String> parent_path = 0) {
  LogGroupInDirectoryBuilder builder_(_fbb);
  builder_.add_parent_path(parent_path);
  builder_.add_log_group(log_group);
  return builder_.Finish();
}

inline flatbuffers::Offset<LogGroupInDirectory> CreateLogGroupInDirectoryDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LogGroup> log_group = 0,
    const char *parent_path = nullptr) {
  return CreateLogGroupInDirectory(_fbb, log_group, parent_path ? _fbb.CreateString(parent_path) : 0);
}

struct Delta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  const Header *header() const { return GetStruct<const Header *>(VT_HEADER); }
  DeltaPayload payload_type() const { return static_cast<DeltaPayload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0)); }
  const void *payload() const { return GetPointer<const void *>(VT_PAYLOAD); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Header>(verifier, VT_HEADER) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PAYLOAD) &&
           VerifyDeltaPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

struct DeltaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(const Header *header) { fbb_.AddStruct(Delta::VT_HEADER, header); }
  void add_payload_type(DeltaPayload payload_type) { fbb_.AddElement<uint8_t>(Delta::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0); }
  void add_payload(flatbuffers::Offset<void> payload) { fbb_.AddOffset(Delta::VT_PAYLOAD, payload); }
  DeltaBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DeltaBuilder &operator=(const DeltaBuilder &);
  flatbuffers::Offset<Delta> Finish() {
    auto o = flatbuffers::Offset<Delta>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Delta> CreateDelta(flatbuffers::FlatBufferBuilder &_fbb,
    const Header *header = 0,
    DeltaPayload payload_type = DeltaPayload::NONE,
    flatbuffers::Offset<void> payload = 0) {
  DeltaBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_header(header);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

struct MkDir_Msg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_RECURSIVE = 6,
    VT_ATTRS = 8
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  bool recursive() const { return GetField<uint8_t>(VT_RECURSIVE, 0) != 0; }
  const LogAttrs *attrs() const { return GetPointer<const LogAttrs *>(VT_ATTRS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_RECURSIVE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTRS) &&
           verifier.VerifyTable(attrs()) &&
           verifier.EndTable();
  }
};

struct MkDir_MsgBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(MkDir_Msg::VT_NAME, name); }
  void add_recursive(bool recursive) { fbb_.AddElement<uint8_t>(MkDir_Msg::VT_RECURSIVE, static_cast<uint8_t>(recursive), 0); }
  void add_attrs(flatbuffers::Offset<LogAttrs> attrs) { fbb_.AddOffset(MkDir_Msg::VT_ATTRS, attrs); }
  MkDir_MsgBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MkDir_MsgBuilder &operator=(const MkDir_MsgBuilder &);
  flatbuffers::Offset<MkDir_Msg> Finish() {
    auto o = flatbuffers::Offset<MkDir_Msg>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<MkDir_Msg> CreateMkDir_Msg(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool recursive = false,
    flatbuffers::Offset<LogAttrs> attrs = 0) {
  MkDir_MsgBuilder builder_(_fbb);
  builder_.add_attrs(attrs);
  builder_.add_name(name);
  builder_.add_recursive(recursive);
  return builder_.Finish();
}

inline flatbuffers::Offset<MkDir_Msg> CreateMkDir_MsgDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool recursive = false,
    flatbuffers::Offset<LogAttrs> attrs = 0) {
  return CreateMkDir_Msg(_fbb, name ? _fbb.CreateString(name) : 0, recursive, attrs);
}

struct SetTree_Msg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TREE = 4
  };
  const LogsConfig *tree() const { return GetPointer<const LogsConfig *>(VT_TREE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TREE) &&
           verifier.VerifyTable(tree()) &&
           verifier.EndTable();
  }
};

struct SetTree_MsgBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tree(flatbuffers::Offset<LogsConfig> tree) { fbb_.AddOffset(SetTree_Msg::VT_TREE, tree); }
  SetTree_MsgBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SetTree_MsgBuilder &operator=(const SetTree_MsgBuilder &);
  flatbuffers::Offset<SetTree_Msg> Finish() {
    auto o = flatbuffers::Offset<SetTree_Msg>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<SetTree_Msg> CreateSetTree_Msg(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LogsConfig> tree = 0) {
  SetTree_MsgBuilder builder_(_fbb);
  builder_.add_tree(tree);
  return builder_.Finish();
}

struct Rm_Msg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_VALIDATE_IS_DIR = 6,
    VT_RECURSIVE = 8
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  bool validate_is_dir() const { return GetField<uint8_t>(VT_VALIDATE_IS_DIR, 0) != 0; }
  bool recursive() const { return GetField<uint8_t>(VT_RECURSIVE, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATE_IS_DIR) &&
           VerifyField<uint8_t>(verifier, VT_RECURSIVE) &&
           verifier.EndTable();
  }
};

struct Rm_MsgBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Rm_Msg::VT_NAME, name); }
  void add_validate_is_dir(bool validate_is_dir) { fbb_.AddElement<uint8_t>(Rm_Msg::VT_VALIDATE_IS_DIR, static_cast<uint8_t>(validate_is_dir), 0); }
  void add_recursive(bool recursive) { fbb_.AddElement<uint8_t>(Rm_Msg::VT_RECURSIVE, static_cast<uint8_t>(recursive), 0); }
  Rm_MsgBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  Rm_MsgBuilder &operator=(const Rm_MsgBuilder &);
  flatbuffers::Offset<Rm_Msg> Finish() {
    auto o = flatbuffers::Offset<Rm_Msg>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Rm_Msg> CreateRm_Msg(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool validate_is_dir = false,
    bool recursive = false) {
  Rm_MsgBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_recursive(recursive);
  builder_.add_validate_is_dir(validate_is_dir);
  return builder_.Finish();
}

inline flatbuffers::Offset<Rm_Msg> CreateRm_MsgDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool validate_is_dir = false,
    bool recursive = false) {
  return CreateRm_Msg(_fbb, name ? _fbb.CreateString(name) : 0, validate_is_dir, recursive);
}

struct Rename_Msg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FROM_PATH = 4,
    VT_TO_PATH = 6
  };
  const flatbuffers::String *from_path() const { return GetPointer<const flatbuffers::String *>(VT_FROM_PATH); }
  const flatbuffers::String *to_path() const { return GetPointer<const flatbuffers::String *>(VT_TO_PATH); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FROM_PATH) &&
           verifier.Verify(from_path()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TO_PATH) &&
           verifier.Verify(to_path()) &&
           verifier.EndTable();
  }
};

struct Rename_MsgBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_from_path(flatbuffers::Offset<flatbuffers::String> from_path) { fbb_.AddOffset(Rename_Msg::VT_FROM_PATH, from_path); }
  void add_to_path(flatbuffers::Offset<flatbuffers::String> to_path) { fbb_.AddOffset(Rename_Msg::VT_TO_PATH, to_path); }
  Rename_MsgBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  Rename_MsgBuilder &operator=(const Rename_MsgBuilder &);
  flatbuffers::Offset<Rename_Msg> Finish() {
    auto o = flatbuffers::Offset<Rename_Msg>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Rename_Msg> CreateRename_Msg(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> from_path = 0,
    flatbuffers::Offset<flatbuffers::String> to_path = 0) {
  Rename_MsgBuilder builder_(_fbb);
  builder_.add_to_path(to_path);
  builder_.add_from_path(from_path);
  return builder_.Finish();
}

inline flatbuffers::Offset<Rename_Msg> CreateRename_MsgDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *from_path = nullptr,
    const char *to_path = nullptr) {
  return CreateRename_Msg(_fbb, from_path ? _fbb.CreateString(from_path) : 0, to_path ? _fbb.CreateString(to_path) : 0);
}

struct SetAttrs_Msg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_ATTRS = 6
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const LogAttrs *attrs() const { return GetPointer<const LogAttrs *>(VT_ATTRS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTRS) &&
           verifier.VerifyTable(attrs()) &&
           verifier.EndTable();
  }
};

struct SetAttrs_MsgBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(SetAttrs_Msg::VT_NAME, name); }
  void add_attrs(flatbuffers::Offset<LogAttrs> attrs) { fbb_.AddOffset(SetAttrs_Msg::VT_ATTRS, attrs); }
  SetAttrs_MsgBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SetAttrs_MsgBuilder &operator=(const SetAttrs_MsgBuilder &);
  flatbuffers::Offset<SetAttrs_Msg> Finish() {
    auto o = flatbuffers::Offset<SetAttrs_Msg>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<SetAttrs_Msg> CreateSetAttrs_Msg(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<LogAttrs> attrs = 0) {
  SetAttrs_MsgBuilder builder_(_fbb);
  builder_.add_attrs(attrs);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetAttrs_Msg> CreateSetAttrs_MsgDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<LogAttrs> attrs = 0) {
  return CreateSetAttrs_Msg(_fbb, name ? _fbb.CreateString(name) : 0, attrs);
}

struct SetLogRange_Msg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_RANGE = 6
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const LogRange *range() const { return GetPointer<const LogRange *>(VT_RANGE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RANGE) &&
           verifier.VerifyTable(range()) &&
           verifier.EndTable();
  }
};

struct SetLogRange_MsgBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(SetLogRange_Msg::VT_NAME, name); }
  void add_range(flatbuffers::Offset<LogRange> range) { fbb_.AddOffset(SetLogRange_Msg::VT_RANGE, range); }
  SetLogRange_MsgBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SetLogRange_MsgBuilder &operator=(const SetLogRange_MsgBuilder &);
  flatbuffers::Offset<SetLogRange_Msg> Finish() {
    auto o = flatbuffers::Offset<SetLogRange_Msg>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<SetLogRange_Msg> CreateSetLogRange_Msg(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<LogRange> range = 0) {
  SetLogRange_MsgBuilder builder_(_fbb);
  builder_.add_range(range);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SetLogRange_Msg> CreateSetLogRange_MsgDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<LogRange> range = 0) {
  return CreateSetLogRange_Msg(_fbb, name ? _fbb.CreateString(name) : 0, range);
}

struct MkLog_Msg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_RANGE = 6,
    VT_MK_INTERMEDIATE_PATHS = 8,
    VT_ATTRS = 10
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const LogRange *range() const { return GetPointer<const LogRange *>(VT_RANGE); }
  bool mk_intermediate_paths() const { return GetField<uint8_t>(VT_MK_INTERMEDIATE_PATHS, 0) != 0; }
  const LogAttrs *attrs() const { return GetPointer<const LogAttrs *>(VT_ATTRS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RANGE) &&
           verifier.VerifyTable(range()) &&
           VerifyField<uint8_t>(verifier, VT_MK_INTERMEDIATE_PATHS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTRS) &&
           verifier.VerifyTable(attrs()) &&
           verifier.EndTable();
  }
};

struct MkLog_MsgBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(MkLog_Msg::VT_NAME, name); }
  void add_range(flatbuffers::Offset<LogRange> range) { fbb_.AddOffset(MkLog_Msg::VT_RANGE, range); }
  void add_mk_intermediate_paths(bool mk_intermediate_paths) { fbb_.AddElement<uint8_t>(MkLog_Msg::VT_MK_INTERMEDIATE_PATHS, static_cast<uint8_t>(mk_intermediate_paths), 0); }
  void add_attrs(flatbuffers::Offset<LogAttrs> attrs) { fbb_.AddOffset(MkLog_Msg::VT_ATTRS, attrs); }
  MkLog_MsgBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MkLog_MsgBuilder &operator=(const MkLog_MsgBuilder &);
  flatbuffers::Offset<MkLog_Msg> Finish() {
    auto o = flatbuffers::Offset<MkLog_Msg>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<MkLog_Msg> CreateMkLog_Msg(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<LogRange> range = 0,
    bool mk_intermediate_paths = false,
    flatbuffers::Offset<LogAttrs> attrs = 0) {
  MkLog_MsgBuilder builder_(_fbb);
  builder_.add_attrs(attrs);
  builder_.add_range(range);
  builder_.add_name(name);
  builder_.add_mk_intermediate_paths(mk_intermediate_paths);
  return builder_.Finish();
}

inline flatbuffers::Offset<MkLog_Msg> CreateMkLog_MsgDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<LogRange> range = 0,
    bool mk_intermediate_paths = false,
    flatbuffers::Offset<LogAttrs> attrs = 0) {
  return CreateMkLog_Msg(_fbb, name ? _fbb.CreateString(name) : 0, range, mk_intermediate_paths, attrs);
}

struct RESET_Msg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONFIG = 4
  };
  const LogsConfig *config() const { return GetPointer<const LogsConfig *>(VT_CONFIG); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CONFIG) &&
           verifier.VerifyTable(config()) &&
           verifier.EndTable();
  }
};

struct RESET_MsgBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_config(flatbuffers::Offset<LogsConfig> config) { fbb_.AddOffset(RESET_Msg::VT_CONFIG, config); }
  RESET_MsgBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RESET_MsgBuilder &operator=(const RESET_MsgBuilder &);
  flatbuffers::Offset<RESET_Msg> Finish() {
    auto o = flatbuffers::Offset<RESET_Msg>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<RESET_Msg> CreateRESET_Msg(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LogsConfig> config = 0) {
  RESET_MsgBuilder builder_(_fbb);
  builder_.add_config(config);
  return builder_.Finish();
}

struct BatchDelta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OPERATIONS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Delta>> *operations() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Delta>> *>(VT_OPERATIONS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OPERATIONS) &&
           verifier.Verify(operations()) &&
           verifier.VerifyVectorOfTables(operations()) &&
           verifier.EndTable();
  }
};

struct BatchDeltaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_operations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Delta>>> operations) { fbb_.AddOffset(BatchDelta::VT_OPERATIONS, operations); }
  BatchDeltaBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BatchDeltaBuilder &operator=(const BatchDeltaBuilder &);
  flatbuffers::Offset<BatchDelta> Finish() {
    auto o = flatbuffers::Offset<BatchDelta>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<BatchDelta> CreateBatchDelta(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Delta>>> operations = 0) {
  BatchDeltaBuilder builder_(_fbb);
  builder_.add_operations(operations);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchDelta> CreateBatchDeltaDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Delta>> *operations = nullptr) {
  return CreateBatchDelta(_fbb, operations ? _fbb.CreateVector<flatbuffers::Offset<Delta>>(*operations) : 0);
}

inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, Any type) {
  switch (type) {
    case Any::NONE: return true;
    case Any::NoValueSet: return verifier.VerifyTable(reinterpret_cast<const NoValueSet *>(union_obj));
    case Any::UInt8: return verifier.VerifyTable(reinterpret_cast<const UInt8 *>(union_obj));
    case Any::Int: return verifier.VerifyTable(reinterpret_cast<const Int *>(union_obj));
    case Any::Bool: return verifier.VerifyTable(reinterpret_cast<const Bool *>(union_obj));
    case Any::ULong: return verifier.VerifyTable(reinterpret_cast<const ULong *>(union_obj));
    case Any::Long: return verifier.VerifyTable(reinterpret_cast<const Long *>(union_obj));
    case Any::String: return verifier.VerifyTable(reinterpret_cast<const String *>(union_obj));
    default: return false;
  }
}

inline bool VerifyDeltaPayload(flatbuffers::Verifier &verifier, const void *union_obj, DeltaPayload type) {
  switch (type) {
    case DeltaPayload::NONE: return true;
    case DeltaPayload::MkDir_Msg: return verifier.VerifyTable(reinterpret_cast<const MkDir_Msg *>(union_obj));
    case DeltaPayload::Rm_Msg: return verifier.VerifyTable(reinterpret_cast<const Rm_Msg *>(union_obj));
    case DeltaPayload::Rename_Msg: return verifier.VerifyTable(reinterpret_cast<const Rename_Msg *>(union_obj));
    case DeltaPayload::SetAttrs_Msg: return verifier.VerifyTable(reinterpret_cast<const SetAttrs_Msg *>(union_obj));
    case DeltaPayload::SetLogRange_Msg: return verifier.VerifyTable(reinterpret_cast<const SetLogRange_Msg *>(union_obj));
    case DeltaPayload::MkLog_Msg: return verifier.VerifyTable(reinterpret_cast<const MkLog_Msg *>(union_obj));
    case DeltaPayload::BatchDelta: return verifier.VerifyTable(reinterpret_cast<const BatchDelta *>(union_obj));
    case DeltaPayload::SetTree_Msg: return verifier.VerifyTable(reinterpret_cast<const SetTree_Msg *>(union_obj));
    default: return false;
  }
}

inline const facebook::logdevice::logsconfig::fbuffers::LogAttrs *GetLogAttrs(const void *buf) {
  return flatbuffers::GetRoot<facebook::logdevice::logsconfig::fbuffers::LogAttrs>(buf);
}

inline bool VerifyLogAttrsBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<facebook::logdevice::logsconfig::fbuffers::LogAttrs>(nullptr);
}

inline void FinishLogAttrsBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<facebook::logdevice::logsconfig::fbuffers::LogAttrs> root) {
  fbb.Finish(root);
}

}  // namespace fbuffers
}  // namespace logsconfig
}  // namespace logdevice
}  // namespace facebook

#endif  // FLATBUFFERS_GENERATED_LOGSCONFIGSTRUCTURES_FACEBOOK_LOGDEVICE_LOGSCONFIG_FBUFFERS_H_
